# 1 Java内存模型

计算机在执行程序时，每条指令都是在 CPU 中执行的，而执行指令过程中，会涉及到数据的读取和写入。

由于程序运行过程中的**临时数据**是存放在**主存（物理内存）**当中的，这时就存在一个问题，由于 CPU 执行速度很快，而从内存读取数据和向内存写入数据的过程跟 CPU 执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在 CPU 里面就有了**高速缓存【Cache】**。

也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到 CPU 的高速缓存当中，那么 CPU 进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据**刷新**到主存当中。举个简单的例子，比如下面的这段代码：`i = i + 1;`

当线程执行这个语句时，会顺序有以下步骤：

1. 先从主存当中读取变量 i 的值；
2. 然后复制一份到**高速缓存**当中；
3. 然后 CPU 执行指令对变量 i 进行加 1 操作；
4. 然后将数据写入高速缓存；
5. 最后将高速缓存中 i 最新的值刷新到主存当中。

那将这个简单的赋值实例放在多线程并发上，比如同时有 2 个线程执行这段代码，假如初始时变量 i 的值为0，那么我们希望两个线程执行完之后变量 i 的值变为2，但是事实会是这样吗？

可能存在下面一种情况：初始时，两个线程分别读取变量 i 的值存入各自所在的 CPU 的高速缓存当中，然后线程 1 进行加 1 操作，然后把变量 i 的最新值 1 写入到内存。此时线程 2 的高速缓存当中变量 i 的值还是 0，进行加 1 操作之后，变量 i 的值为1，然后线程 2 把变量 i 的值写入内存。最终结果变量 i 的值是1，而不是2。这就是著名的**缓存一致性问题**。通常称这种被多个线程访问的变量为**共享变量**。

也就是说，如果一个变量在多个 CPU 中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。

# 2 并发编程

在**并发编程**中，我们通常会遇到以下三个问题：原子性问题，可见性问题，有序性问题。

## 2.1 原子性

**原子性**描述的是：一个操作或者多个操作要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。

一个很经典的例子就是银行账户转账问题：从账户 A 向账户 B 转1000元。那么必然：从账户 A 减去1000元，往账户 B 加上1000元。如果上述操作不具备原子性，有可能会导致从账户 A 中转出的钱，没有进入到账户 B 中！

只有操作具备了原子性，才能保证不出现一些意外问题。

## 2.2 可见性

可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

~~~java
// 线程 A 执行的代码
int i = 0;
i = 10;

// 线程 B 执行的代码
j = i;
~~~

假若执行线程 A 的是 CPU1，执行线程 B 的是 CPU2。由上面的分析可知，当线程 A 执行 i =10 这句时，会先把 i 的初始值加载到 CPU1 的高速缓存中，然后赋值为 10，那么在 CPU1 的高速缓存当中 i 的值变为10了，却没有立即写入到主存当中。此时线程 B 执行 j = i，它会先去主存读取i的值并加载到 CPU2 的缓存当中，注意此时内存当中 i 的值还是0，那么就会使得 j 的值为0，而不是10.

这就是不具备可见性时：线程 A 对变量 i 修改了之后，线程 B 没有立即看到线程 A 修改的值。

## 2.3 有序性

有序性：即**程序执行的顺序按照代码的先后顺序执**行。举个简单的例子，看下面这段代码：

~~~java
int i = 0;              
boolean flag = false;
i = 1;                //语句1  
flag = true;          //语句2
~~~

上面代码定义了一个 int 型变量，定义了一个 boolean 类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么 JVM 在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生**指令重排序**（Instruction Reorder）。

下面解释一下什么是指令重排序，一般来说，**处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的**。

比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。

但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同。此外，处理器在进行重排序时是会考虑指令之间的**数据依赖性**。

虽然**重排序不会影响单个线程内程序执行的结果**，但是多线程呢？

~~~java
//线程1:
context = loadContext();   //语句1
inited = true;             //语句2
 
//线程2:
while(!inited ){
	sleep()
}
doSomethingwithconfig(context);
~~~

上面代码中，由于语句 1 和语句 2 没有数据依赖性，因此可能会被重排序。

假如发生了重排序，在线程 1 执行过程中先执行语句 2，而此是线程 2 会以为初始化工作已经完成，那么就会跳出 while 循环，去执行 doSomethingwithconfig(context) 方法，而此时 context 并没有被初始化，就会导致程序出错。

从上面可以看出，**指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性**。

也就是说，**要想并发程序正确地执行，必须要保证原子性、可见性以及有序性**。只要有一个没有被保证，就有可能会导致程序运行不正确。

# 3 语言性能

上述提到的—— `Java` 内存模型、原子性、可见性、有序性，都是并发编程中需要考虑的，也是在程序设计中需要考虑的、现实的计算机底层模型。那 Java 编程语言为我们提供了哪些方法来确保多线程并发时的正确性？

在 Java 虚拟机规范中试图定义一种 Java 内存模型（`Java Memory Model，JMM`）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。那么 Java 内存模型规定了哪些东西呢？它定义了程序中**变量的访问规则**，往大一点说是定义了**程序执行的次序**。注意，为了获得较好的执行性能，Java 内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在 Java 内存模型中，也会存在缓存一致性问题和指令重排序的问题。

Java 内存模型规定所有的变量都是存在**主存**当中（类似于前面说的**物理内存**），每个线程都有自己的**工作内存**（类似于前面的**高速缓存**）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。每个线程不能访问其他线程的工作内存。

在 Java 中，**对基本数据类型的变量的读取和赋值**操作是**原子性**操作，即这些操作是不可被中断的，要么执行，要么不执行。来看一个简单的实例：

~~~java
x = 10;
y = x;
x++;
x = x + 1;
~~~

上述语句中只有语句1的操作是原子性的，其他语句都可以拆分成多个原子性操作。而多个原子性操作合并在一起是不具备原子性的。也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。

**Java 内存模型只保证了基本读取和赋值是原子性操作**，如果要实现更大范围操作的原子性，可以通过 synchronized 和 Lock 来实现。由于 synchronized 和 Lock 能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。

对于可见性，Java 提供了 volatile 关键字来保证**可见性**。当一个共享变量被 volatile 修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。

而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。

另外，通过 synchronized 和 Lock 也能够保证可见性，synchronized 和 Lock 能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。

在 Java 内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。在 Java 里面，可以通过 volatile 关键字来保证一定的“有序性”。另外可以通过 synchronized 和 Lock 来保证有序性。很显然，synchronized 和Lock 保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。

# 4 volatile 关键字

一旦一个共享变量（类的成员变量、类的静态成员变量）被 volatile 修饰之后，那么就具备了两层语义：

* 保证了不同线程对这个变量进行操作时的**可见性**，即一个线程修改了某个变量的值，这新值对其他线程来说是**立即可见的**。
* 禁止进行指令重排序。

来看一个实例代码：

~~~java
// 线程 A
boolean stop = false;
while(!stop){
	dosomething();
}

// 线程 B
stop = true;
~~~

但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。

下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程 A 在运行的时候，会将 stop 变量的值拷贝一份放在自己的工作内存当中。

那么当线程 B 更改了 stop 变量的值之后，但是还没来得及写入主存当中，线程 B 转去做其他事情了，那么线程 A 由于不知道线程 B 对 stop 变量的更改，因此还会一直循环下去。

但是用 volatile 修饰之后就变得不一样了：

1. 使用 volatile 关键字会强制将修改的值立即写入主存；
2. 使用 volatile 关键字的话，当线程 B 进行修改时，会导致线程 A 的工作内存中缓存变量 stop 的缓存行无效（反映到硬件层的话，就是 CPU 的 L1 或者 L2 缓存中对应的缓存行无效）；
3. 由于线程 A 的工作内存中缓存变量 stop 的缓存行无效，所以线程 A 再次读取变量 stop 的值时会去主存读取。

此时可以保证线程 A 能够读取到最新的有效值。因此，我们**可以说 `volatile` 是可以保证可见性的**。

下面再来看一个例子：

~~~java

package com.zebra.lang.thread;

public class VolatileUsage {
	// 使用 volatile 声明类的成员变量
    private volatile int count = 0;

    public void increaseCount() {
        count++;
    }

    public static void main(String[] args) {
        VolatileUsage volatileUsage = new VolatileUsage();

        for (int i = 0; i < 1000; i++) {
            // main 线程下创建多个工作线程
            new Thread(new Runnable() {

                @Override
                public void run() {
                    int index = 0;
                    // 每个子线程都连续不断对类的成员变量做自增操作
                    while (index < 100) {
                        volatileUsage.increaseCount();
                        
                        index++;
                    }
                }
            }).start();
        }

        while (Thread.activeCount() > 1) {
            Thread.yield();
        }

        System.out.println("volatileUsage.count:" + volatileUsage.count);
    }

}
~~~

实际执行的结果，大多数情况下是小于 1000000 的。

volatile 关键字**不能保证程序执行的原子性**。可见性只能保证每次读取的是最新的值，但是 volatile 没办法保证对变量的操作的原子性。

Java 的内存模型中提及：**自增操作是不具备原子性的**，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行。volatile 关键只能保证多个线程能够读取到数据源的最新内容。

因此，上述程序的根源在于：自增操作不具备原子性，导致了即便是使用 volatile 修饰成员变量，仍然无法得到正确的结果。

那 volatile 能够保证**有序性**吗？

~~~java
// x、y为非volatile变量
// flag为volatile变量
 
x = 2;        //语句1
y = 0;        //语句2
flag = true;  //语句3
x = 4;         //语句4
y = -1;       //语句5
~~~

volatile 关键字能够禁止指令重排序，能够在一定程序上保证有序性。volatile 关键字能够保证：语句1和2始终在 `flag = true` 之前执行，也能够保证语句4和5始终在其之后执行。

观察含有 volatile 声明的**汇编语句**，可以发现增加了 `lock` 前缀指令【相当于一个**内存栅栏**】，能够保证：

1. 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；
2. 它会强制将对缓存的修改操作立即写入主存；
3. 如果是写操作，它会导致其他CPU中对应的缓存行无效。

synchronized 关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而 volatile 关键字在某些情况下性能要优于 synchronized，但是要注意 volatile 关键字是无法替代 synchronized 关键字的，**因为 volatile 关键字无法保证操作的原子性**。

在程序中必须保证操作的原子性【也是 volatile 关键字缺乏的特性】，才能保证在多线程并发的时候能够正确执行。

可将上述程序修改为：

~~~java

package com.zebra.lang.thread;

import java.util.concurrent.atomic.AtomicInteger;

public class VolatileUsage {
    // 使用 volatile 声明类的成员变量，原子性对象
    private volatile AtomicInteger count = new AtomicInteger(0);

    public void increaseCount() {
        // Java 提供了线程安全的操作接口
        count.incrementAndGet();
    }

    public static void main(String[] args) {
        VolatileUsage volatileUsage = new VolatileUsage();

        for (int i = 0; i < 1000; i++) {
            // main 线程下创建多个工作线程
            new Thread(new Runnable() {

                @Override
                public void run() {
                    int index = 0;
                    // 每个子线程都连续不断对类的成员变量做自增操作
                    while (index < 100) {
                        volatileUsage.increaseCount();
                        
                        index++;
                    }
                }
            }).start();
        }

        while (Thread.activeCount() > 1) {
            Thread.yield();
        }

        System.out.println("volatileUsage.count:" + volatileUsage.count);
    }

}
~~~

